package network

import (
	"fmt"
	"net"
	"os/exec"
	"strconv"
	"strings"
)

// IPConfig represents an IP configuration
type IPConfig struct {
	Address string
	Netmask string
	Gateway string
	DNS     []string
}

// SetStaticIP sets a static IP configuration for an interface
func SetStaticIP(interfaceName string, config IPConfig) error {
	// Validate the IP address
	if net.ParseIP(config.Address) == nil {
		return fmt.Errorf("invalid IP address: %s", config.Address)
	}

	// Validate the netmask
	if net.ParseIP(config.Netmask) == nil {
		return fmt.Errorf("invalid netmask: %s", config.Netmask)
	}

	// Validate the gateway
	if config.Gateway != "" && net.ParseIP(config.Gateway) == nil {
		return fmt.Errorf("invalid gateway: %s", config.Gateway)
	}

	// Convert netmask to CIDR notation
	_, ipNet, err := net.ParseCIDR(config.Address + "/" + maskToCIDRString(config.Netmask))
	if err != nil {
		return fmt.Errorf("failed to parse CIDR: %w", err)
	}
	cidr, _ := ipNet.Mask.Size()

	// Get the current state of the interface
	cmd := exec.Command("ip", "addr", "show", "dev", interfaceName)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Errorf("failed to get interface state: %w", err)
	}

	// Check if the interface already has an IP address
	if strings.Contains(string(output), "inet ") {
		// If it does, flush the interface first
		cmd = exec.Command("ip", "addr", "flush", "dev", interfaceName)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to flush interface: %w", err)
		}
	}

	// Set the IP address
	cmd = exec.Command("ip", "addr", "add", config.Address+"/"+strconv.Itoa(cidr), "dev", interfaceName)
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to set IP address: %w", err)
	}

	// Set the default gateway if provided
	if config.Gateway != "" {
		// First, delete any existing default route for this interface
		cmd = exec.Command("ip", "route", "del", "default", "dev", interfaceName)
		// Ignore errors - the route might not exist
		cmd.Run()

		// Add the new default route
		cmd = exec.Command("ip", "route", "add", "default", "via", config.Gateway, "dev", interfaceName)
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to set default gateway: %w", err)
		}
	}

	// Set DNS servers if provided
	if len(config.DNS) > 0 {
		// Create resolv.conf content
		var resolvConf strings.Builder
		resolvConf.WriteString("# Generated by Network Manager TUI\n")
		for _, dns := range config.DNS {
			if net.ParseIP(dns) != nil {
				resolvConf.WriteString(fmt.Sprintf("nameserver %s\n", dns))
			}
		}

		// Write to resolv.conf
		cmd = exec.Command("sh", "-c", fmt.Sprintf("echo '%s' > /etc/resolv.conf", resolvConf.String()))
		if err := cmd.Run(); err != nil {
			return fmt.Errorf("failed to set DNS servers: %w", err)
		}
	}

	// Bring the interface up
	cmd = exec.Command("ip", "link", "set", "dev", interfaceName, "up")
	if err := cmd.Run(); err != nil {
		return fmt.Errorf("failed to bring interface up: %w", err)
	}

	return nil
}

// SetDHCP configures an interface to use DHCP
func SetDHCP(interfaceName string) error {
	// First, check if dhclient is available
	_, err := exec.LookPath("dhclient")
	if err != nil {
		return fmt.Errorf("dhclient not found: %w", err)
	}

	// Kill any existing dhclient process for this interface
	killCmd := exec.Command("pkill", "-f", fmt.Sprintf("dhclient.*%s", interfaceName))
	// Ignore errors - the process might not exist
	killCmd.Run()

	// Flush existing IP configuration
	flushCmd := exec.Command("ip", "addr", "flush", "dev", interfaceName)
	if err := flushCmd.Run(); err != nil {
		return fmt.Errorf("failed to flush interface: %w", err)
	}

	// Bring the interface up
	upCmd := exec.Command("ip", "link", "set", "dev", interfaceName, "up")
	if err := upCmd.Run(); err != nil {
		return fmt.Errorf("failed to bring interface up: %w", err)
	}

	// Start dhclient
	dhcpCmd := exec.Command("dhclient", "-v", interfaceName)
	if err := dhcpCmd.Start(); err != nil {
		return fmt.Errorf("failed to start DHCP client: %w", err)
	}

	return nil
}

// maskToCIDRString converts a subnet mask to CIDR notation
func maskToCIDRString(mask string) string {
	// Parse the mask as an IP
	ip := net.ParseIP(mask)
	if ip == nil {
		return "24" // Default to /24 if invalid
	}

	// Convert to 4-byte representation
	ipv4 := ip.To4()
	if ipv4 == nil {
		return "24" // Default to /24 if not IPv4
	}

	// Count the bits
	bits := 0
	for _, b := range ipv4 {
		bits += bits8(b)
	}

	return strconv.Itoa(bits)
}

// bits8 counts the number of bits set in a byte
func bits8(b byte) int {
	count := 0
	for i := 0; i < 8; i++ {
		if (b & (1 << uint(i))) != 0 {
			count++
		}
	}
	return count
}

// GetCurrentIPConfig gets the current IP configuration for an interface
func GetCurrentIPConfig(interfaceName string) (IPConfig, error) {
	var config IPConfig

	// Get interface address
	cmd := exec.Command("ip", "-4", "addr", "show", "dev", interfaceName)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return config, fmt.Errorf("failed to get interface address: %w", err)
	}

	// Parse the IP address and netmask
	addrOutput := string(output)
	ipLine := strings.Split(addrOutput, "inet ")[1]
	if ipLine != "" {
		ipParts := strings.Split(ipLine, " ")
		if len(ipParts) > 0 {
			cidr := ipParts[0]
			cidrParts := strings.Split(cidr, "/")
			if len(cidrParts) == 2 {
				config.Address = cidrParts[0]
				
				// Convert CIDR to netmask
				cidrBits, _ := strconv.Atoi(cidrParts[1])
				config.Netmask = cidrToMaskString(cidrBits)
			}
		}
	}

	// Get default gateway
	routeCmd := exec.Command("ip", "route", "show", "dev", interfaceName)
	routeOutput, err := routeCmd.CombinedOutput()
	if err != nil {
		// Non-fatal, just continue without gateway
	} else {
		routeLines := strings.Split(string(routeOutput), "\n")
		for _, line := range routeLines {
			if strings.HasPrefix(line, "default via ") {
				parts := strings.Split(line, " ")
				if len(parts) >= 3 {
					config.Gateway = parts[2]
					break
				}
			}
		}
	}

	// Get DNS servers
	dnsCmd := exec.Command("cat", "/etc/resolv.conf")
	dnsOutput, err := dnsCmd.CombinedOutput()
	if err != nil {
		// Non-fatal, just continue without DNS
	} else {
		dnsLines := strings.Split(string(dnsOutput), "\n")
		for _, line := range dnsLines {
			if strings.HasPrefix(line, "nameserver ") {
				parts := strings.Split(line, " ")
				if len(parts) >= 2 {
					config.DNS = append(config.DNS, parts[1])
				}
			}
		}
	}

	return config, nil
}

// cidrToMaskString converts CIDR bits to a subnet mask string
func cidrToMaskString(bits int) string {
	// Create a mask with the given number of bits
	mask := net.CIDRMask(bits, 32)
	return fmt.Sprintf("%d.%d.%d.%d", mask[0], mask[1], mask[2], mask[3])
}
